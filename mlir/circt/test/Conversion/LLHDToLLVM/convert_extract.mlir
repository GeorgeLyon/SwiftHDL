// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// RUN: circt-opt %s --convert-llhd-to-llvm --split-input-file | FileCheck %s

// CHECK-LABEL:   llvm.func @convertSigExtract(
// CHECK-SAME:                                 %[[VAL_0:.*]]: i5,
// CHECK-SAME:                                 %[[VAL_1:.*]]: !llvm.ptr<struct<(ptr, i64, i64, i64)>>) {
// CHECK:           %[[VAL_2:.*]] = llvm.mlir.constant(0 : i32) : i32
// CHECK:           %[[VAL_3:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_4:.*]] = llvm.getelementptr %[[VAL_1]]{{\[}}%[[VAL_2]], 0] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<ptr>
// CHECK:           %[[VAL_5:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr<ptr>
// CHECK:           %[[VAL_6:.*]] = llvm.getelementptr %[[VAL_1]]{{\[}}%[[VAL_2]], 1] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_7:.*]] = llvm.load %[[VAL_6]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_8:.*]] = llvm.mlir.constant(2 : i32) : i32
// CHECK:           %[[VAL_9:.*]] = llvm.mlir.constant(3 : i32) : i32
// CHECK:           %[[VAL_10:.*]] = llvm.getelementptr %[[VAL_1]]{{\[}}%[[VAL_2]], 2] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_11:.*]] = llvm.load %[[VAL_10]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_12:.*]] = llvm.getelementptr %[[VAL_1]]{{\[}}%[[VAL_2]], 3] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_13:.*]] = llvm.load %[[VAL_12]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_14:.*]] = llvm.zext %[[VAL_0]] : i5 to i64
// CHECK:           %[[VAL_15:.*]] = llvm.add %[[VAL_7]], %[[VAL_14]]  : i64
// CHECK:           %[[VAL_16:.*]] = llvm.ptrtoint %[[VAL_5]] : !llvm.ptr to i64
// CHECK:           %[[VAL_17:.*]] = llvm.mlir.constant(8 : i64) : i64
// CHECK:           %[[VAL_18:.*]] = llvm.udiv %[[VAL_15]], %[[VAL_17]]  : i64
// CHECK:           %[[VAL_19:.*]] = llvm.add %[[VAL_16]], %[[VAL_18]]  : i64
// CHECK:           %[[VAL_20:.*]] = llvm.inttoptr %[[VAL_19]] : i64 to !llvm.ptr
// CHECK:           %[[VAL_21:.*]] = llvm.urem %[[VAL_15]], %[[VAL_17]]  : i64
// CHECK:           %[[VAL_22:.*]] = llvm.mlir.undef : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_23:.*]] = llvm.insertvalue %[[VAL_20]], %[[VAL_22]][0] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_24:.*]] = llvm.insertvalue %[[VAL_21]], %[[VAL_23]][1] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_25:.*]] = llvm.insertvalue %[[VAL_11]], %[[VAL_24]][2] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_26:.*]] = llvm.insertvalue %[[VAL_13]], %[[VAL_25]][3] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_27:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_28:.*]] = llvm.alloca %[[VAL_27]] x !llvm.struct<(ptr, i64, i64, i64)> {alignment = 4 : i64} : (i32) -> !llvm.ptr<struct<(ptr, i64, i64, i64)>>
// CHECK:           llvm.store %[[VAL_26]], %[[VAL_28]] : !llvm.ptr<struct<(ptr, i64, i64, i64)>>
// CHECK:           llvm.return
// CHECK:         }
func.func @convertSigExtract (%c : i5, %sI32 : !llhd.sig<i32>) {
  %0 = llhd.sig.extract %sI32 from %c : (!llhd.sig<i32>) -> !llhd.sig<i10>

  return
}

// CHECK-LABEL:   llvm.func @convertSigArraySlice(
// CHECK-SAME:                                    %[[VAL_0:.*]]: i2,
// CHECK-SAME:                                    %[[VAL_1:.*]]: !llvm.ptr<struct<(ptr, i64, i64, i64)>>) {
// CHECK:           %[[VAL_2:.*]] = llvm.mlir.constant(0 : i32) : i32
// CHECK:           %[[VAL_3:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_4:.*]] = llvm.getelementptr %[[VAL_1]]{{\[}}%[[VAL_2]], 0] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<ptr>
// CHECK:           %[[VAL_5:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr<ptr>
// CHECK:           %[[VAL_6:.*]] = llvm.getelementptr %[[VAL_1]]{{\[}}%[[VAL_2]], 1] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_7:.*]] = llvm.load %[[VAL_6]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_8:.*]] = llvm.mlir.constant(2 : i32) : i32
// CHECK:           %[[VAL_9:.*]] = llvm.mlir.constant(3 : i32) : i32
// CHECK:           %[[VAL_10:.*]] = llvm.getelementptr %[[VAL_1]]{{\[}}%[[VAL_2]], 2] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_11:.*]] = llvm.load %[[VAL_10]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_12:.*]] = llvm.getelementptr %[[VAL_1]]{{\[}}%[[VAL_2]], 3] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_13:.*]] = llvm.load %[[VAL_12]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_14:.*]] = llvm.zext %[[VAL_0]] : i2 to i3
// CHECK:           %[[VAL_15:.*]] = llvm.mlir.constant(0 : i32) : i32
// CHECK:           %[[VAL_16:.*]] = llvm.bitcast %[[VAL_5]] : !llvm.ptr to !llvm.ptr<array<4 x i4>>
// CHECK:           %[[VAL_17:.*]] = llvm.getelementptr %[[VAL_16]]{{\[}}%[[VAL_15]], %[[VAL_14]]] : (!llvm.ptr<array<4 x i4>>, i32, i3) -> !llvm.ptr<i4>
// CHECK:           %[[VAL_18:.*]] = llvm.bitcast %[[VAL_17]] : !llvm.ptr<i4> to !llvm.ptr
// CHECK:           %[[VAL_19:.*]] = llvm.mlir.undef : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_20:.*]] = llvm.insertvalue %[[VAL_18]], %[[VAL_19]][0] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_21:.*]] = llvm.insertvalue %[[VAL_7]], %[[VAL_20]][1] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_22:.*]] = llvm.insertvalue %[[VAL_11]], %[[VAL_21]][2] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_23:.*]] = llvm.insertvalue %[[VAL_13]], %[[VAL_22]][3] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_24:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_25:.*]] = llvm.alloca %[[VAL_24]] x !llvm.struct<(ptr, i64, i64, i64)> {alignment = 4 : i64} : (i32) -> !llvm.ptr<struct<(ptr, i64, i64, i64)>>
// CHECK:           llvm.store %[[VAL_23]], %[[VAL_25]] : !llvm.ptr<struct<(ptr, i64, i64, i64)>>
// CHECK:           llvm.return
// CHECK:         }
func.func @convertSigArraySlice (%c : i2, %sArr : !llhd.sig<!hw.array<4xi4>>) {
  %1 = llhd.sig.array_slice %sArr at %c : (!llhd.sig<!hw.array<4xi4>>) -> !llhd.sig<!hw.array<2xi4>>

  return
}

// CHECK-LABEL:   llvm.func @convertSigStructExtract(
// CHECK-SAME:                                       %[[VAL_0:.*]]: !llvm.ptr<struct<(ptr, i64, i64, i64)>>) {
// CHECK:           %[[VAL_1:.*]] = llvm.mlir.constant(0 : i32) : i32
// CHECK:           %[[VAL_2:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_3:.*]] = llvm.getelementptr %[[VAL_0]]{{\[}}%[[VAL_1]], 0] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<ptr>
// CHECK:           %[[VAL_4:.*]] = llvm.load %[[VAL_3]] : !llvm.ptr<ptr>
// CHECK:           %[[VAL_5:.*]] = llvm.getelementptr %[[VAL_0]]{{\[}}%[[VAL_1]], 1] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_6:.*]] = llvm.load %[[VAL_5]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_7:.*]] = llvm.mlir.constant(2 : i32) : i32
// CHECK:           %[[VAL_8:.*]] = llvm.mlir.constant(3 : i32) : i32
// CHECK:           %[[VAL_9:.*]] = llvm.getelementptr %[[VAL_0]]{{\[}}%[[VAL_1]], 2] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_10:.*]] = llvm.load %[[VAL_9]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_11:.*]] = llvm.getelementptr %[[VAL_0]]{{\[}}%[[VAL_1]], 3] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_12:.*]] = llvm.load %[[VAL_11]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_13:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_14:.*]] = llvm.mlir.constant(0 : i32) : i32
// CHECK:           %[[VAL_15:.*]] = llvm.bitcast %[[VAL_4]] : !llvm.ptr to !llvm.ptr<struct<(i3, i2, i1)>>
// CHECK:           %[[VAL_16:.*]] = llvm.getelementptr %[[VAL_15]]{{\[}}%[[VAL_14]], 1] : (!llvm.ptr<struct<(i3, i2, i1)>>, i32) -> !llvm.ptr<i2>
// CHECK:           %[[VAL_17:.*]] = llvm.bitcast %[[VAL_16]] : !llvm.ptr<i2> to !llvm.ptr
// CHECK:           %[[VAL_18:.*]] = llvm.mlir.undef : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_19:.*]] = llvm.insertvalue %[[VAL_17]], %[[VAL_18]][0] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_20:.*]] = llvm.insertvalue %[[VAL_6]], %[[VAL_19]][1] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_21:.*]] = llvm.insertvalue %[[VAL_10]], %[[VAL_20]][2] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_22:.*]] = llvm.insertvalue %[[VAL_12]], %[[VAL_21]][3] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_23:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_24:.*]] = llvm.alloca %[[VAL_23]] x !llvm.struct<(ptr, i64, i64, i64)> {alignment = 4 : i64} : (i32) -> !llvm.ptr<struct<(ptr, i64, i64, i64)>>
// CHECK:           llvm.store %[[VAL_22]], %[[VAL_24]] : !llvm.ptr<struct<(ptr, i64, i64, i64)>>
// CHECK:           llvm.return
// CHECK:         }
func.func @convertSigStructExtract (%sTup : !llhd.sig<!hw.struct<foo: i1, bar: i2, baz: i3>>) {
  %1 = llhd.sig.struct_extract %sTup["bar"] : !llhd.sig<!hw.struct<foo: i1, bar: i2, baz: i3>>

  return
}

// CHECK-LABEL:   llvm.func @convertSigArrayGet(
// CHECK-SAME:                                  %[[VAL_0:.*]]: !llvm.ptr<struct<(ptr, i64, i64, i64)>>,
// CHECK-SAME:                                  %[[VAL_1:.*]]: i2) {
// CHECK:           %[[VAL_2:.*]] = llvm.mlir.constant(0 : i32) : i32
// CHECK:           %[[VAL_3:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_4:.*]] = llvm.getelementptr %[[VAL_0]]{{\[}}%[[VAL_2]], 0] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<ptr>
// CHECK:           %[[VAL_5:.*]] = llvm.load %[[VAL_4]] : !llvm.ptr<ptr>
// CHECK:           %[[VAL_6:.*]] = llvm.getelementptr %[[VAL_0]]{{\[}}%[[VAL_2]], 1] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_7:.*]] = llvm.load %[[VAL_6]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_8:.*]] = llvm.mlir.constant(2 : i32) : i32
// CHECK:           %[[VAL_9:.*]] = llvm.mlir.constant(3 : i32) : i32
// CHECK:           %[[VAL_10:.*]] = llvm.getelementptr %[[VAL_0]]{{\[}}%[[VAL_2]], 2] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_11:.*]] = llvm.load %[[VAL_10]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_12:.*]] = llvm.getelementptr %[[VAL_0]]{{\[}}%[[VAL_2]], 3] : (!llvm.ptr<struct<(ptr, i64, i64, i64)>>, i32) -> !llvm.ptr<i64>
// CHECK:           %[[VAL_13:.*]] = llvm.load %[[VAL_12]] : !llvm.ptr<i64>
// CHECK:           %[[VAL_14:.*]] = llvm.zext %[[VAL_1]] : i2 to i3
// CHECK:           %[[VAL_15:.*]] = llvm.mlir.constant(0 : i32) : i32
// CHECK:           %[[VAL_16:.*]] = llvm.bitcast %[[VAL_5]] : !llvm.ptr to !llvm.ptr<array<4 x i4>>
// CHECK:           %[[VAL_17:.*]] = llvm.getelementptr %[[VAL_16]]{{\[}}%[[VAL_15]], %[[VAL_14]]] : (!llvm.ptr<array<4 x i4>>, i32, i3) -> !llvm.ptr<i4>
// CHECK:           %[[VAL_18:.*]] = llvm.bitcast %[[VAL_17]] : !llvm.ptr<i4> to !llvm.ptr
// CHECK:           %[[VAL_19:.*]] = llvm.mlir.undef : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_20:.*]] = llvm.insertvalue %[[VAL_18]], %[[VAL_19]][0] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_21:.*]] = llvm.insertvalue %[[VAL_7]], %[[VAL_20]][1] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_22:.*]] = llvm.insertvalue %[[VAL_11]], %[[VAL_21]][2] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_23:.*]] = llvm.insertvalue %[[VAL_13]], %[[VAL_22]][3] : !llvm.struct<(ptr, i64, i64, i64)>
// CHECK:           %[[VAL_24:.*]] = llvm.mlir.constant(1 : i32) : i32
// CHECK:           %[[VAL_25:.*]] = llvm.alloca %[[VAL_24]] x !llvm.struct<(ptr, i64, i64, i64)> {alignment = 4 : i64} : (i32) -> !llvm.ptr<struct<(ptr, i64, i64, i64)>>
// CHECK:           llvm.store %[[VAL_23]], %[[VAL_25]] : !llvm.ptr<struct<(ptr, i64, i64, i64)>>
// CHECK:           llvm.return
// CHECK:         }
func.func @convertSigArrayGet(%sArr : !llhd.sig<!hw.array<4xi4>>, %c : i2) {
  %1 = llhd.sig.array_get %sArr[%c] : !llhd.sig<!hw.array<4xi4>>

  return
}
